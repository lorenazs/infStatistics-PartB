library()
install.packages(ggplot2)
install.packages('ggplot2')
install.packages('devtools')
install.packages('swirl')
library(swirl)
swirl()
5+7
x <-- 5 +7
x <- 5 +7
x
y <- x - 3
y
c(1.1,9,3.14)
z <- c(1.1,9,3.14)
?c()
?c
z
c(z,555,z)
z *2 +100
mySqrt <- sqrt(z-1)
mySqrt
myDiv<- z/mySqrt
myDiv
c(1,2,3) + c(0,10)
c(1,2,3,4) + c(0,10)
c(1,2,3,4)+c(0,10,100)
1:20
pi:10
15:1
?:
?':'
?":"
?´:´
?`:`
seq(1,20)
seq(0,10,by=0.5)
seq(5,10,30)
seq(5,10,length=30)
my_seq <- seq(5,10,length=30)
length(my_seq)
1:length(my_seq)
seq(along=my_seq)
seq_along(my_seq)
rep(0,times=40)
rep(c(0,1,2),times=10)
rep(c(0,1,2),each=10)
library(swirl)
swirl()
num_vect <- c(0.5,55,-10,6)
tf <- num_vect < 1
tf
num_vect <- >= 6
num_vect >= 6
my_char <- c("my","name","is")
my_char<- c("My","name","is")
my_chars
my_char
paste(my_char,collaptse = " ")
paste(my_char,collapse = " ")
my_name <- c(my_char,"Lorena")
my_name
paste(my_name,collapse= " ")
paste("Hello","world!",sep=" ")
paste(1:3,c("X","Y","Z"),sep = "")
paste(LETTERS,1:4,sep="-")
x <- c(44,NA,5,NA)
x * 3
y <- rnorm(1000)
z <- rep(NA,1000)
myData <- sample(c(y,z),100)
myData
myNA <- is.na(myData)
myNA
myData == NA
sum(myNA)
myData
0/0
Inf - Inf
x
x[1:10]
x[is.na(x)]
y <- x[!is.na(x)]
y
y[y>0]
x[x>0]
x[!is.na(x) & x > 0]
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10)]
x[-c(2,10)]
vect <- c(foo=1,bar=2,norf=NA)
vect <- c(foo=11,bar=2,norf=NA)
vect
names(vect)
vect2<- c(11,2,NA)
names(vect2)<- c("foo","bar","norf")
identical(vect,vect2)
vect["bar"]
vect[c("foo","bar")]
myVector <- 1:20
myVector
dim(myVector)
length(myVector)
dim(myVector) <- c(4,5)
dim(myVector)
attributes(myVector)
myVector
class(myVector)
myMatrix <- myVector
?matrix
myMatrix2 <- matrix(data=1:20,nrow=4,ncol=5)
identical(myMatrix,myMatrix2)
patients <- c("Bill","Gina","Kelly","Sean")
cbind(patients,myMatrix)
myData <- data.frame(patients,myMatrix)
myData
class(myData)
cnames <- c("patient","age","weight","bp","rating","test")
colnames(myData)
?colnames
colnames(myData)<- cnames
myData
cube <- function(x,n){x^3}
cube(3)
x<-1:10
if (x < 5){x<-0}
f <-function(x){g<-function(y){y+z} z<-4}
f<-function(x){}
f<-function(x){
g<-function(y){
y+z  }
z<-4
x + g(x)  }
z=10
f(3)
x<- m((1,2,3),(4,5,6))
x<- c((1,2,3),(4,5,6))
x<- matrix(c(1,2,3,4,5,6),nrow=3,ncol=3,byrow=TRUE)
x
x<- matrix(c(1,2,3,4,5,6,7,8,9),nrow=3,ncol=3,byrow=TRUE)
x
solve(x)
?solve
x
solve(x,...)
solve(x)
x
x ∞∞
x %*% solve(x)
x <- c(0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1)
x <- matrix(x,ncol=5, byrow=TRUE)
x <- c(0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0)
x <- matrix(x,ncol=5, byrow=TRUE)
X
x
x %*% solve(x)
x<- c(0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0)
x <- matrix(x,ncol=5, byrow=TRUE)
x %*% solve(x)
x
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y){
x <<-y
inverse <<- NULL
}
get() <- function()x
## set and get methods for the inverse matrix
setinverse <- function(inv) inverse <<- inv
getinverse <- function()inverse
list(set=set, get=get, setinverse=setinverse,getinverse=getinverse)
}
## cacheSolve function calculates the inverse of the matrix x
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inversematrix <- x$getinverse()
if(!is.null(inversematrix))   ## the inverse of the matrix already exists
{
message('getting cache data')
return(inversematrix)
}
data<- x$get()      ## calculate the inverse of the matrix if not exists
inversematrix <-data %*% solve(data)
x$setinversematrix(inversematrix)
}
mm <- makeCacheMatrix(x)
class(x)
makeCacheMatrix(x)
}
makeVector()
makeVector()
makeVector(c(1,2,3))
}
vect <-1:20
vect
makeVector(vect)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector(vect)
spvect <-makeVector(vect)
spvect$get()
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(spvect)
cachemean(spvect)
x
matriz <- makeCacheMatrix(x)
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
get() <- function() x
## set and get methods for the inverse matrix
setinverse <- function(inv) inverse <<- inv
getinverse <- function()inverse
list(set=set, get=get, setinverse=setinverse,getinverse=getinverse)
}
## cacheSolve function calculates the inverse of the matrix x
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inversematrix <- x$getinverse()
if(!is.null(inversematrix))   ## the inverse of the matrix already exists
{
message('getting cache data')
return(inversematrix)
}
data<- x$get()      ## calculate the inverse of the matrix if not exists
inversematrix <-data %*% solve(data)
x$setinversematrix(inversematrix)
}
matriz <- makeCacheMatrix(x)
makeCacheMatrix <- function(x = matrix()) {
message(x)
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
get() <- function() x
## set and get methods for the inverse matrix
setinverse <- function(inv) inverse <<- inv
getinverse <- function()inverse
list(set=set, get=get, setinverse=setinverse,getinverse=getinverse)
}
matriz <- makeCacheMatrix(x)
makeCacheMatrix <- function(x = matrix()) {
message(x)
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
get <- function() x
## set and get methods for the inverse matrix
setinverse <- function(inv) inverse <<- inv
getinverse <- function()inverse
list(set=set, get=get, setinverse=setinverse,getinverse=getinverse)
}
matriz <- makeCacheMatrix(x)
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
get <- function() x
## set and get methods for the inverse matrix
setinverse <- function(inv) inverse <<- inv
getinverse <- function()inverse
list(set=set, get=get, setinverse=setinverse,getinverse=getinverse)
}
matriz <- makeCacheMatrix(x)
matriz$get
matriz$get()
cacheSolve(matriz)
matriz
attributes(matriz)
matriz$getinverse()
d<-matriz$get()
d
im<- d %*% solve(d)
im
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y){
x <<- y
inverse <<- NULL
}
get <- function() x
## set and get methods for the inverse matrix
setinverse <- function(inv) inverse <<- inv
getinverse <- function()inverse
list(set=set, get=get, setinverse=setinverse,getinverse=getinverse)
}
## cacheSolve function calculates the inverse of the matrix x
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inversematrix <- x$getinverse()
if(!is.null(inversematrix))   ## the inverse of the matrix already exists
{
message('getting cache data')
return(inversematrix)
}
data<- x$get()      ## calculate the inverse of the matrix if not exists
inversematrix <-data %*% solve(data)
x$setinverse(inversematrix)
}
x
matriz <- makeCacheMatrix(x)
matriz$get()
matriz$getinverse()
cacheSolve(matriz)
matriz$getinverse()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inversematrix <- x$getinverse()
if(!is.null(inversematrix))   ## the inverse of the matrix already exists
{
message('getting cache data')
return(inversematrix)
}
data<- x$get()      ## calculate the inverse of the matrix if not exists
inversematrix <-data %*% solve(data)
x$setinverse(inversematrix)
inversematrix
}
matriz$getinverse()
cacheSolve(matriz)
set.seed(1)
rpois(5,2)
?dpois
library(datasets)
Rprof()
fit<- lm(y~x1+x2)
Rprof(NULL)
summaryRprof()
best('eee','tos')
{
if (outcome != 'pneumonia') |( outcome != 'heart failure') | (outcome != 'heart attack')
{
stop('invalid outcome')
}
else
best('ggg','tos')
source('~/ejerciciosR-Rprogramming/rprog_data_ProgAssignment3-data/best.R')
}
best('ggg','tos')
best('hh','tos')
install.packages('RMySQL')
install.packages('RMySQL')
install.packages('httr')
defaults write org.R-project.R force.LANG en_US.UTF-8
install.packages('httr')
install.packages('RMySQL')
qnorm(0.05,mean=11,sd=2)
qnorm(x,mean=11,sd=2)
qnorm(,mean=11,sd=2)
qnorm(mean=11,sd=2)
ppois(40,lambda=(9*5)
)
pnorm(70,mean=80,sd=10)
qnorm(0.95,mean=1100,sd=75)
choose(4,5) * 0.5^5 + choose(5,5)*0.5^5
ppois(10,5*3)
0.5*0.5
=75*75
75*75
q(0.95,mean=1100,sd=75)
qnorm(0.95,mean=1100,sd=75)
qnorm(0.95,mean=1100,sd=75)
10/sqrt(100)
pnorm(16,mean=15,sd=1)
pnorm(15,mean=15,sd=1)
pnorm(14,mean=15,sd=1)
pnorm(16,mean=15,sd=1)
x= sqrt(1/12)
y=sqrt(100)
x
y
x/y
0.5-(x/y)
choose(5,4)*0.5^5 + choose(5,5)*0.5^5
1100 + c(-1,1) * qt(.975,8) * 30/sqrt(9)
-2 + c(-1,1) * qt(.975,8)*2.1/sqrt(9)
-2 + c(-1,1) * qt(.975,8)*2.6/sqrt(9)
-2 + c(-1,1) * qt(.975,8)*1.5/sqrt(9)
-2 + c(-1,1) * qt(.975,8)*0.3/sqrt(9)
sqrt(0.6)
-2 + c(-1,1) * qt(.975)*0.77/sqrt(10)
-2 + c(-1,1) * qt(.975,10)*0.77/sqrt(10)
sqrt(0.68)
-2 + c(-1,1) * qt(.975,10)*0.82/sqrt(10)
-2 + c(-1,1) * qt(.975,20)*0.82/sqrt(20)
-2 + c(-1,1) * qt(.975,20)*0.77/sqrt(20)
1100 + c(-1,1) * qt(.975,8) * 30/sqrt(9)
1100 + c(-1,1) * qt(.80,8) * 30/sqrt(9)
1091-1108
1076-1123
0.60-0.68
sqrt(-0.08)
(0.6+0.68)/2
sqrt((2*0.64)/10)
-2 + c(-1,1) * qt(.975)*0.357
-2 + c(-1,1) * qt(.975,9)*0.357
-2 - 2.101*0.357
-2 + 2.101*0.357
((1.5*1.5)+(1.8*1.8))/2
sqrt((2*2.745)/18)
sqrt((2*2.745)/9)
-3 - 2.12*0.781
-3 + 2.12*0.781
-4 - 2.12*0.781
-4 + 2.12*0.781
1.5*1.5
1.8*1.8
(2.25+3.84)/2
2*3.045
6.09/9
srqt(6.09/9)
sqrt(6.09/9)
-4 - 2.12*0.822
-4 + 2.12*0.822
((1.5*1.5)+(1.8*1.8))/2
(2*2.745)/2
(2*2.745)/9
sqrt(0.61)
-3-1
-4 - (1.746)*(0.781)
-4 + (1.746)*(0.781)
setwd("~/Documents/infStatistics-PartB")
data(ToothGrowth)
summary(ToothGrowth)
View(ToothGrowth)
library(knitr)
install.packages('knitr')
coplot(len ~ dose | supp, data = ToothGrowth, panel = panel.smooth,
xlab = "ToothGrowth data: length vs dose, given type of supplement")
